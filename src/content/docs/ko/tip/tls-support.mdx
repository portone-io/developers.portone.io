---
title: TLS 지원 범위
description: 포트원 API의 TLS 지원 변동 계획 및 가이드를 확인할 수 있습니다.
---

import Figure from "~/components/gitbook/Figure.astro";

import javaTLSSupportTable from "./_assets/tls_support/TLS_support_for_java.png";

2024년 x월 x일 부터 포트원을 이용하는 고객님들의 개인정보 및 결제정보들을 더욱 안전하게 보호하기 위해  
API 서버(api.iamport.kr)의 지원 프로토콜 및 Cipher Suite 범위가 변경됩니다.

<table>
  <tr>
    <td>
      <b>Protocol</b>
    </td>
    <td>
      <b>Cipher Suite</b>
    </td>
    <td>
      <b>2024년 x월 x일 이전</b>
    </td>
    <td>
      <b>2024년 x월 x일 이후</b>
    </td>
  </tr>
  <tr>
    <td colspan="2">HTTP</td>
    <td rowspan="24" style="text-align: center">
      O
    </td>
    <td rowspan="13" style="text-align: center">
      X
    </td>
  </tr>
  <tr>
    <td colspan="2">TLSv1.0</td>
  </tr>
  <tr>
    <td colspan="2">TLSv1.1</td>
  </tr>
  <tr>
    <td rowspan="18">TLSv1.2</td>
    <td>AES256-SHA</td>
  </tr>
  <tr>
    <td>AES128-SHA</td>
  </tr>
  <tr>
    <td>AES128-GCM-SHA256</td>
  </tr>
  <tr>
    <td>AES128-SHA256</td>
  </tr>
  <tr>
    <td>AES256-GCM-SHA384</td>
  </tr>
  <tr>
    <td>AES256-SHA256</td>
  </tr>
  <tr>
    <td>ECDHE-ECDSA-AES128-SHA</td>
  </tr>
  <tr>
    <td>ECDHE-RSA-AES128-SHA</td>
  </tr>
  <tr>
    <td>ECDHE-RSA-AES256-SHA</td>
  </tr>
  <tr>
    <td>ECDHE-ECDSA-AES256-SHA</td>
  </tr>
  <tr>
    <td>ECDHE-ECDSA-AES128-SHA256</td>
    <td rowspan="11" style="text-align: center">
      O
    </td>
  </tr>
  <tr>
    <td>ECDHE-RSA-AES128-SHA256</td>
  </tr>
  <tr>
    <td>ECDHE-ECDSA-AES256-SHA384</td>
  </tr>
  <tr>
    <td>ECDHE-RSA-AES256-SHA384</td>
  </tr>
  <tr>
    <td>ECDHE-ECDSA-AES128-GCM-SHA256</td>
  </tr>
  <tr>
    <td>ECDHE-RSA-AES128-GCM-SHA256</td>
  </tr>
  <tr>
    <td>ECDHE-ECDSA-AES256-GCM-SHA384</td>
  </tr>
  <tr>
    <td>ECDHE-RSA-AES256-GCM-SHA384</td>
  </tr>
  <tr>
    <td rowspan="3">TLSv1.3</td>
    <td>TLS-AES-128-GCM-SHA256</td>
  </tr>
  <tr>
    <td>TLS-AES-256-GCM-SHA384</td>
  </tr>
  <tr>
    <td>TLS-CHACHA20-POLY1305-SHA256</td>
  </tr>
</table>
<br />

위 변경을 요약하자면 다음과 같습니다.

- HTTP 평문 통신 지원 중단
- TLS 1.0, 1.1 지원 중단
- 특정 조건을 만족하지 않는 Cipher Suite에 대한 지원 중단

어떠한 이유로 위와 같은 변경이 이루어졌는지, 왜 해당 프로토콜 및 Cipher Suite를 사용하면 안되는지 각 변경점 별로 설명합니다.

### HTTP 평문 통신 지원 중단

TLS를 이용하지 않는 HTTP 통신은 근본적으로 데이터를 암호화하지 않는다는 문제가 있습니다.
이는 암호화/복호화 등과 무관하게 통신 중간에 데이터를 가로챌 수만 있다면 어떤 데이터든 중간자가 평문 그대로의 데이터를 확인, 이를 악의적으로 이용할 수 있다는 것을 의미합니다.
HTTP 통신은 또한 기본적으로 인증서를 이용한 인증 절차를 걸치지 않기때문에 다양한 방법으로 데이터 갈취가 가능합니다.
그렇기에 DNS 서버를 겨냥해 캐시 악성 침입을 하는 스푸핑이나 다른 도메인의 네임서버나 IP로 리디렉션하는 하이재킹, 두 서버 사이에서 데이터를 도청하는 중간자 공격 (Man in the middle attack, MITM)에 매우 취약합니다.

### TLS 1.0, 1.1 지원 중단

TLS 1.0과 1.1은 각각 1999년, 2006년에 공개된 오래된 보안 표준으로 이미 많은 취약점이 노출된 바 있습니다.
이에 따라 2021년 3월 국제 인터넷 표준화 기구인 IETF에서 발표한 RFC 8996에서는 TLS 1.0 및 1.1을 deprecate 시킨다 명시되어있으며
AWS, Google, Apple, Microsoft 등 많은 국제 기업들이 본인들의 제품 및 API 이용 시 TLS 1.2 미만 버전에 대한 제한을 두고 있습니다.
TLS 1.0 및 1.1을 사용함에 따라 발생할 수 있는 문제 및 취약점에는 다음과 같은 것들이 있습니다.

#### BEAST (Browser Exploit Against SSL/TLS) 공격

TLS 1.1 미만 버전에서 발생할 수 있는 BEAST 공격은 중간자 공격으로 시작됩니다.
TLS 1.0(그리고 더 낮은 수준의 프로토콜)은 CBC(Cipher block chaining) 방식으로 데이터들을 암호화합니다. 복잡성을 높이기 위해 IV(initial vector)개념을 사용하지만 TLS 1.0에서는 직전의 암호화된 블록 데이터를 이용하여 IV값을 계산하기에 중간자 공격을 통해 데이터에 접근만 할 수 있다면 이는 무의미해집니다.
블록 암호화의 경우 암호화된 데이터의 길이가 고정값이고 공격자가 알아야할 정보(ex. 인증 세션 값)를 제외한 정보는 얼마든지 유추가 가능하기떄문에 (ex. host, encoding이나 charset 관련 헤더) 공격자가 계산해야할 경우의 수가 매우 줄어듭니다.
이러한 문제점은 TLS 1.1에서 IV를 유추할 수 없도록 수정하면서 해결되었습니다.

#### 취약한 암호화 알고리즘 사용

TLS 1.0 및 1.1은 handshake protocol에서 사용하는 finished message를 구성하거나 pseudorandom function(PRF)에서 해시를 만들 때 등 암호화 해시 함수가 필요한 경우 MD5와 SHA-1에 의존하고있습니다.
문제는 두 해시 함수 모두 해시 충돌(다른 입력값으로 같은 해시를 생성)에 취약할 뿐 더러 컴퓨팅 자원의 발전으로 인해 같은 해시를 생성하는 입력값 계산에 드는 시간이 점점 줄어들고 있다는 것입니다.
이러한 문제는 TLS 1.2에서 해시함수를 MD5 SHA1으로 고정하는 것이 아닌 Cipher Suite에 명시되어있는 MAC(Message authentication code) 알고리즘을 사용하도록 하면서 해결되었습니다.
뿐만아니라 TLS 1.2부터는 데이터 블록 암호화 운용 시 GCM(Galois/Counter Mode)같은 AEAD(Authenticated encryption)을 허용하는 등 더 높은 수준의 보안을 지원합니다.

#### POODLE (The Padding Oracle On Downgraded Legacy Encryption) 공격

POODLE 공격 역시 BEAST와 같이 중간자 공격으로 시작됩니다.
공격자가 의도적으로 클라이언트와 서버 사이의 연결을 반복적으로 drop시키거나 잘못된 메시지를 전송하는 경우 서버는 클라이언트와의 통신 프로토콜이 맞지 않는 것으로 간주하여 더 낮은 버전의 프로토콜로 fallback 시킵니다.
SSL 3.0까지 버전이 내려간 이후에는 SSL 3.0의 블록 암호 패딩 검증에서의 허점을 이용합니다.
SSL 3.0에서는 패딩 값에 대한 검증을 하지 않고 패딩 길이에 대해서만 검증 합니다. 공격자는 데이터 조작 시 서버의 응답을 통해 패딩(길이) 검증에 실패하였는지 MAC 검증에 실패하였는지 구분이 가능하기에 패딩 값은 임의로 유지한 채 길이만을 조절해가면서 반복적으로 요청을 보내는 것을 통해 암호화 블록에서 패딩을 제외한 실제 데이터의 길이 밎 값을 도출해낼 수 있습니다.
TLS 1.2 이하의 프로토콜을 사용하는 웹서버에서는 낮은 버전의 프로토콜로 fallback되지 않도록 허용 프로토콜을 제한하여 해결할 수 있지만 TLS 1.3부터는 근본적인 원인인 중간자 공격을 막음으로써 POODLE 공격을 방어합니다.

### 특정 조건을 만족하지 않는 Cipher Suite에 대한 지원 중단

Cipher Suite란 TLS 통신시 사용되는 암호 알고리즘의 집합을 의미합니다.
포트원에서는 기존에 지원하던 Cipher Suite 중 일부 집합에 대한 지원을 중단하며 이는 다음과 같은 기준을 충족하지 않는 집합에 해당합니다.

- Forward Secrecy(순방향 비밀성) 지원
- SHA-1 해시 함수 미사용

각 기준에 대한 설명은 다음과 같습니다.

#### Forward Secrecy(순방향 비밀성) 지원

TLS 통신 중 잠재적으로 발생할 수 있는 위험 요소 중 하나는 키교환 알고리즘에 의해 생성된 세션키가 유출되었을 때 해당 세션키의 수명이 일시적이지 않다면 과거 세션에서 주고받았던 데이터들까지 해독될 수 있다는 것입니다.
Forward Secrecy를 지원한다는 것은 이와 같은 문제점을 보완하기 위해 매 세션마다 새로운 키를 생성함으로써 세션키가 유출되더라도 해당 세션을 제외한 다른 세션에는 영향을 미치지 않는 다는 것을 의미합니다.

#### SHA-1 해시 함수 미사용

SHA-1에 대한 문제점은 위 _취약한 알고리즘 사용_ 관련 내용에서 설명한 바 있습니다.
미국 국립표준기술연구소(National Institute of Standards and Technology, NIST)에서는 2011년 SHA-1을 deprecated 시킴과 동시에 2030년까지는 모두 대체되어야한다고 발표하였으며 이에 따라 Google, Microsoft 등의 기업들에서 자신들의 제품에 대해 SHA-1 사용 및 지원을 중단한다 선언하였습니다.

---

## TLS 버전 업 및 Cipher Suite 업그레이드에 대한 가이드

지원 중단 예정인 TLS 버전 및 Cipher Suite를 사용하는 것으로 확인 된 언어 및 버전에 대해 TLS 버전 업 및 Cipher Suite 업그레이드에 대한 가이드를 제공합니다.
포트원에서는 사용 가능 Cipher Suite에 대해서도 일부에 대해서만 사용이 가능한 TLS 1.2보다 모든 Cipher Suite에 대해 사용이 가능한 TLS 1.3으로의 업그레이드를 권장합니다.

### Java 6

Java 6은 기본적으로 TLS 1.2를 지원하지 않습니다.

<Figure
  src={javaTLSSupportTable}
  caption="출처: https://www.ateam-oracle.com/post/transport-level-security-tls-and-java"
/>

JDK 6u121 버전부터는 TLS 1.2를 지원하지만 default TLS 버전은 여전히 1.0일 뿐 더러 Java 6의 JCE(Java Cryptography Extension) Provider가 타원곡선 암호화 알고리즘을 지원하지 않기때문에 단순 JDK 버전 컨트롤만으로는 지원 중단되는 Cipher Suite 퇴역이 불가능합니다.
이에 따라 Java 6에서 포트원 통신 규격을 만족하도록 만들 수 있는 방법 2가지를 설명합니다.

#### 1. Java 8 이상으로 버전 업그레이드

가장 바람직한 방법은 공식 지원기간이 이미 종료된 Java 6에서 상위 버전으로 업그레이드하는 것입니다.
2023년 9월에 출시된 Java 21(LTS)로 업그레이드하는 것이 가장 바람직한 방법이지만 Java 6에서 한번에 높은 버전으로 점프하는 것은 체크해야할 side effect가 매우 많습니다.
반대로 바로 윗 버전인 Java 7의 경우 TLS 1.2를 지원하긴 하나 default TLS 버전은 1.0이기에 system property 혹은 코드 수정이 동반되어야합니다. 또한 Java 7 역시 Java 6과 같이 지원이 중단되었기에 Java 7로의 업그레이드는 권장하지 않습니다.
제일 side effect가 적으면서 합리적인 방법은 Java 8(LTS)로 업그레이드하는 것으로 Java 8의 경우 default TLS 버전이 1.2이며 JDK 8u261 이상부터는 TLS 1.3 톨신을 지원하기 때문에 조건에 충족합니다.

#### 2. 외부 라이브러리를 이용한 구현체 강제 주입

TLS 1.2 통신 및 ECC(타원곡선 암호화) 알고리즘을 사용하는 Cipher Suite 지원에 필요한 JCE(Java Cryptography Extension) 및 JSSE(Java Secure Socket Extension) 구현체를 외부 라이브러리의 것으로 이용하는 방법입니다.
본 가이드에서는 `Bouncy Castle`이라는 오픈소스 라이브러리를 이용한 예시를 설명합니다.

1. [https://www.bouncycastle.org/latest_releases.html](https://www.bouncycastle.org/latest_releases.html)에 접속하여

- `bcprov-jdk15to18-{LATEST}`
- `bctls-jdk15to18-{LATEST}.jar`
- `bcutil-jdk15to18-{LATEST}.jar`
  파일을 다운로드 받습니다.

2. 세 jar 파일을 `${JAVA_HOME}/jre/lib/ext` directory로 복사합니다.
3. `${JAVA_HOME}/jre/lib/security` directory 내 `java.security` 파일을 아래와 같이 수정합니다.

<pre>
  <span style="font-weight: bold;background-color: lightyellow">#Before</span>
  security.provider.1=sun.security.provider.Sun security.provider.2=sun.security.rsa.SunRsaSign
  security.provider.3=com.sun.net.ssl.internal.ssl.Provider security.provider.4=com.sun.crypto.provider.SunJCE
  security.provider.5=sun.security.jgss.SunProvider security.provider.6=com.sun.security.sasl.Provider
  security.provider.7=org.jcp.xml.dsig.internal.dom.XMLDSigRI security.provider.8=sun.security.smartcardio.SunPCSC
  <span style="font-weight: bold;background-color: lightyellow">#After</span>
  <span style="color: gray"># Add provider with higher priority</span>
  <span style="color:red;font-weight: bold">
    security.provider.1=org.bouncycastle.jce.provider.BouncyCastleProvider
  </span>
  <span style="color:red;font-weight: bold">
    security.provider.2=org.bouncycastle.jsse.provider.BouncyCastleJsseProvider
  </span>
  <span style="color: gray"># Lower priority of existing providers</span>
  security.provider.<span style="color:red;font-weight: bold">3</span>=sun.security.provider.Sun
  security.provider.<span style="color:red;font-weight: bold">4</span>=sun.security.rsa.SunRsaSign
  security.provider.<span style="color:red;font-weight: bold">5</span>=com.sun.net.ssl.internal.ssl.Provider
  security.provider.<span style="color:red;font-weight: bold">6</span>=com.sun.crypto.provider.SunJCE
  security.provider.<span style="color:red;font-weight: bold">7</span>=sun.security.jgss.SunProvider
  security.provider.<span style="color:red;font-weight: bold">8</span>=com.sun.security.sasl.Provider
  security.provider.<span style="color:red;font-weight: bold">9</span>=org.jcp.xml.dsig.internal.dom.XMLDSigRI
  security.provider.<span style="color:red;font-weight: bold">10</span>=sun.security.smartcardio.SunPCSC
  <span style="color: gray"># Change default SocketFactory implementation</span>
  <span style="color:red;font-weight: bold">
    ssl.SocketFactory.provider=org.bouncycastle.jsse.provider.SSLSocketFactoryImpl
  </span>
</pre>

_추가되는 line을 제외한 나머지 기존 security provider들은 예시와 다를 수 있습니다._

4. [https://www.oracle.com/java/technologies/jce-6-download.html](https://www.oracle.com/java/technologies/jce-6-download.html)에서 `jce_policy-6.zip` 파일을 다운로드 받습니다.
5. 압축을 푼 후

- `US_export_policy.jar`
- `local_policy.jar`
  두 파일을 `${JAVA_HOME}/jre/lib/security` directory 내에 덮어씌웁니다.

### Java 7

Java 7의 경우 TLS 1.2를 지원하기는 하나 default TLS 버전은 여전히 1.0입니다.

<Figure
  src={javaTLSSupportTable}
  caption="출처: https://www.ateam-oracle.com/post/transport-level-security-tls-and-java"
/>

뿐만 아니라 JDK 버전에 따라 포트원에서 허용하는 Cipher Suite 조건인 1. Forward secrecy 지원 2. SHA-1 미사용 을 만족하는 Cipher Suite를 지원하지 않기도 합니다.
본 가이드에서는 Java 7에서 포트원 보안 규격에 맞는 TLS 버전 및 Cipher suite 설정에 대한 방법 2가지를 제공합니다.

#### 1. Java 8 이상으로 버전 업그레이드

가장 바람직한 방법은 공식 지원기간이 이미 종료된 Java 7에서 상위 버전으로 업그레이드하는 것입니다.
2023년 9월에 출시된 Java 21(LTS)로 업그레이드하는 것이 가장 바람직한 방법이지만 Java 7에서 한번에 높은 버전으로 점프하는 것은 체크해야할 side effect가 매우 많습니다.
제일 side effect가 적으면서 합리적인 방법은 Java 8(LTS)로 업그레이드하는 것으로 Java 8의 경우 default TLS 버전이 1.2이며 JDK 8u261 이상부터는 TLS 1.3 톨신을 지원하기 때문에 조건에 충족합니다.

#### 2. JDK 버전 업그레이드 및 1.2 사용 설정

Java 7 최초 release 버전에서는 포트원에서 허용하는 Cipher suite를 지원하고 있지 않습니다.
해당 Cipher suite는 JDK 7u191 버전부터 지원하기 시작하였으며 JDK 7u321 버전부터 default Cipher Suite에 대한 우선순위를 해당 기준(FS 지원, SHA-1 미사용)에 따라 적용하므로 별도의 설정 없이 Cipher Suite 조건 충족을 만족하기 위해서는 JDK 버전을 7u321 이상으로 업그레이드 해야합니다.

<br />
Cipher Suite에 대한 설정이 완료되었다면 사용 TLS 버전을 1.0에서 1.2로 설정하는 작업이
필요합니다. TLS 버전을 설정하는 방법은 1. System property를 설정하는 방법 2. Socket
client의 TLS 버전을 지정하여 설정하는 방법 2가지가 존재합니다.{" "}

**1. System property**

설정 `jdk.tls.client.protocols` system property를 이용해 default TLS 버전을 1.2로
강제하는 방법입니다. > `https.protocols` system property 또한 TLS 버전 컨트롤에 이용될
수 있으나 해당 property의 경우 https 통신 시 `HttpsURLConnection` class나 `URL.openstream`
function을 이용하는 경우에만 적용되기 때문에 `jdk.tls.client.protocols` property를
설정하시는 방법을 권장드립니다.

Java 애플리케이션 구동 시 아래와 같은 system property 설정을 추가합니다.

```shell
java -Djdk.tls.client.protocols="TLSv1.2" ...
```

주의할 점은 해당 방법은 SSL socket client에서 이용 가능한 TLS 버전을 1.2만 허용 가능하게 하는 방법으로 만약 코드상으로 통신 시 TLS 버전을 1.2 이외의 버전으로 설정하고있을 경우 에러가 발생할 수 있습니다.

**2. Socket client의 TLS 버전 지정**

코드상으로 socket client가 이용 가능한/통신할 TLS 버전을 직접 지정해줄 수 있습니다. 지정은 3가지 방법으로 가능합니다.

1. SSLSocket/SSLEngine/SSLServerSocket API를 이용

```java
sslSocket.setEnabledProtocols(new String[] {"TLSv1.2"});
```

2. SSLContext 생성자를 이용

```java
SSLContext ctx = SSLContext.getInstance("TLSv1.2");
```

3. SSLParameters API를 이용

```java
sslParameters.setProtocols(new String[] {"TLSv1.2"});
```

#### 3. 외부 라이브러리를 이용한 구현체 강제 주입

Java 6 가이드에서 소개한 외부 라이브러리를 이용한 구현체를 강제주입하여 TLS 버전 및 Cipher Suite를 설정할 수 있습니다.
방법은 Java 6 가이드의 *3. 외부 라이브러리를 이용한 구현체 강제 주입*과 동일합니다.

### Java 8

Java 8에서는 default로 TLS 1.2 통신을 지원합니다. 만약 Java 8 버전을 쓰고 있으나 통신이 TLS 1.2 미만으로 이루어지고 있다면 system property나 코드 레벨에서 TLS 버전을 강제하고있는 것은 아닌지 확인이 필요하며
만약 강제하고있을 경우 이를 해제하여 TLS 1.2버전으로 통신 혹은 JDK 버전을 8u261 이상으로 업데이트하여 TLS 1.3을 기본적으로 사용하도록 설정이 필요합니다.
