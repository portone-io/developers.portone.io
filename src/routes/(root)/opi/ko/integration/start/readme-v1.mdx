---
title: 결제 연동 시작하기
description: 결제 연동을 시작합니다.
targetVersions: ["v1"]
versionVariants:
  v2: /ko/integration/start/readme-v2
---

import Figure from "~/components/Figure";
import Details from "~/components/gitbook/Details";
import VersionGate from "~/components/gitbook/VersionGate";
import Youtube from "~/components/gitbook/Youtube";
import Hint from "~/components/Hint";

import imageAuthpayExample from "./_assets/authpay-example.png";
import imageAuthpayFlow from "./_assets/authpay-flow.png";
import Image1 from "./_assets/subscription.png";

## **인증결제**

## 인증 결제란? <span id="definition" />

인증 결제는 결제 시 PG사로부터 결제에 대한 인증 결과 수신 이후 해당 인증키로 결제를 요청하는
결제 방식을 지칭합니다. 국내에서 제일 많이 볼 수 있는 결제 방식으로 결제 주문 페이지에서 결제가
요청되면 각 PG사의 결제창이 활성화되고, 그 후 고객이 선택한 카드사에 따른 카드사 전용 결제 모듈에서
인증이 완료되면 해당 인증값을 통해 결제를 요청하는 흐름으로 결제가 진행됩니다.

<Figure src={imageAuthpayFlow} caption="일반적인 인증 결제 플로우" />

<Hint style="info">
  실제 결제 요청을 위한 통신은 고객사 서버와 PG사 서버 간에 직접적으로 이루어지며,
  해당 결제 요청 과정에 카드 정보는 포함되지 않습니다.
</Hint>

인증 결제는 인증 방법에 따라 전통적으로 아래 두 가지 형태로 구분됩니다.

- ISP 결제 : 공개 키 기반의 전자인증서를 통해 사전에 등록된 카드 정보를 인증하는 방식
- MPI 결제 : 카드 번호, CVC, 안심클릭 비밀번호를 입력하여 카드 정보를 인증하는 방식

최근에는 대부분의 카드사에서 카드사 자체 간편결제를 지원하고 있으며, 고객은 사전에 카드를
등록하고 결제 시 결제 비밀번호를 이용하여 간편하게 결제를 요청할 수 있는 구조를 가지고
있습니다.

<Figure src={imageAuthpayExample} caption="인증 결제 사용 예시" />

## 인증 결제 연동하기

<Details>
  <Details.Summary>
    <strong>영상으로 보기</strong>
  </Details.Summary>

  <Details.Content>
    <Youtube videoId="DhcQFLYV9Q8" caption="포트원 인증 결제의 이해 - 쇼핑몰 멀티PG 연동하기" />
  </Details.Content>
</Details>

### 1. 포트원 SDK 설치하기 <span id="sdk-installation" />

포트원은 다양한 PG의 결제창을 통일된 방법으로 호출할 수 있도록 자바스크립트 SDK를 제공합니다.
브라우저에서 포트원 SDK를 호출하여 결제를 진행하게 됩니다.

<VersionGate v="v1">
  결제창 연동을 진행할 주문 페이지에 아래 JS 라이브러리를 추가합니다.

  ```html
  <script src="https://cdn.iamport.kr/v1/iamport.js"></script>
  ```

  <Youtube videoId="FLyOmbtnr48" caption="포트원 라이브러리 추가하기" />
</VersionGate>

### 2. 결제 요청하기

<VersionGate v="v1">
  #### SDK 초기화하기 <span id="sdk-initialization" />

  포트원 SDK를 사용하여 결제창을 호출하려면, 먼저 포트원 SDK를 초기화하여야 합니다.

  먼저, 관리자 콘솔의 결제 연동 페이지에서 **고객사 식별코드**를 확인해 주세요.

  그리고 결제창을 호출할 페이지에서 다음과 같이 포트원 SDK를 초기화합니다.

  <Hint style="warning">
    아래 초기화 함수를 2회 이상 중복 호출하지 않도록 주의해 주세요.
  </Hint>

  ```ts
  IMP.init("고객사 식별코드"); // 예: 'imp00000000'
  ```

  ##### 하위 상점에서 SDK 초기화하기

  하위 상점에서 SDK를 초기화하려면, `IMP.init()` 함수 대신 `IMP.agency()` 함수를 사용합니다.

  ```ts
  IMP.agency("고객사 식별코드", "티어코드"); // 예: 'imp00000000', '123'
  ```

  <div id="request-payment">
    #### 결제창 불러오기
  </div>

  SDK의 `IMP.request_pay()` 함수를 호출하여 결제 수단에 따른 결제창을 열 수 있습니다.

  아래와 같이 [결제 요청 파라미터](/opi/ko/integration/sdk/javascript-sdk/payrq)를 `request_pay()` 함수의
  첫 인자로 설정하여 호출합니다.

  ```ts
  IMP.request_pay(
    {
      pg: "{PG사 코드}.{상점 ID}",
      pay_method: "card",
      merchant_uid: `payment-${crypto.randomUUID()}`, // 주문 고유 번호
      name: "노르웨이 회전 의자",
      amount: 64900,
      buyer_email: "gildong@gmail.com",
      buyer_name: "홍길동",
      buyer_tel: "010-4242-4242",
      buyer_addr: "서울특별시 강남구 신사동",
      buyer_postcode: "01181",
    },
    function (response) {
      // 결제 종료 시 호출되는 콜백 함수
      // response.imp_uid 값으로 결제 단건조회 API를 호출하여 결제 결과를 확인하고,
      // 결제 결과를 처리하는 로직을 작성합니다.
    },
  );
  ```

  <Youtube videoId="Gq7r5AUoMKs" caption="결제하기 버튼 생성 및 결제창 호출" />
</VersionGate>

<VersionGate v="v2">
  SDK의 `PortOne.requestPayment()` 함수를 호출하여 결제 수단에 따른 결제창을 열 수 있습니다.

  먼저, 관리자 콘솔의 결제 연동 페이지에서 **Store ID**와 사용할 채널의 **채널 키**를 확인해 주세요.

  그리고 아래와 같이 [결제 요청 파라미터](/opi/ko/integration/v2-sdk/payment-request)를
  `requestPayment()` 함수의 첫 인자로 설정하여 호출합니다.

  ```ts
  const response = await PortOne.requestPayment({
    // Store ID 설정
    storeId: "store-4ff4af41-85e3-4559-8eb8-0d08a2c6ceec",
    // 채널 키 설정
    channelKey: "channel-key-893597d6-e62d-410f-83f9-119f530b4b11",
    paymentId: `payment-${crypto.randomUUID()}`,
    orderName: "나이키 와플 트레이너 2 SD",
    totalAmount: 1000,
    currency: "CURRENCY_KRW",
    payMethod: "CARD",
  });
  ```
</VersionGate>

<Hint style="info">
  <VersionGate v="v1">
    **주문 고유 번호(`merchant_uid`) 관련 유의사항**
  </VersionGate>

  <VersionGate v="v2">
    **주문 고유 번호(`paymentId`) 관련 유의사항**
  </VersionGate>

  - 주문 고유 번호는 개별 결제 요청을 구분하기 위해 사용되는 문자열입니다.

  - 따라서 주문 고유 번호는 결제 요청 시 항상 **고유한 값**으로 채번되어야 하며,
    결제 완료 이후 결제 기록 조회나 위변조 대사 작업 시 사용되기 때문에
    고객사 **DB 상에 별도로 저장**해야 합니다.
</Hint>

### 3. 결제 결과 처리하기 <span id="handle-result" />

결제창이 활성화되는 방식에 따라 결제 결과를 획득하는 방법이 상이합니다.

일반적으로 PC 환경에서는 iframe 또는 팝업 방식으로 페이지 이동 없이 결제창이 활성화되며,
따라서 SDK의 반환값을 통해서 결제 결과를 받아 볼 수 있습니다.
반면, 모바일 환경에서는 일반적으로 새로운 페이지로 리다이렉트되는 방식으로 결제창이 활성화되고,
SDK의 반환값 대신 URL의 [쿼리 문자열](http://en.wikipedia.org/wiki/Query_string) 형태로
결제 결과를 받아볼 수 있습니다.

<VersionGate v="v2">
  결제창이 활성화되는 방식은 `windowType` 파라미터를 통해 명시적으로 설정할 수 있습니다.
</VersionGate>

#### SDK 반환값으로 처리하기 <span id="handle-callback" />

<VersionGate v="v1">
  **`request_pay()`** 함수의 두 번째 인자인 **callback** 함수를 통해 결제 결과를 확인할 수 있습니다.

  ```ts
  IMP.request_pay(
    {
      /* 파라미터 생략 */
    },
    async (response) => {
      if (response.error_code != null) {
        return alert(`결제에 실패하였습니다. 에러 내용: ${response.error_msg}`);
      }

      // 고객사 서버에서 /payment/complete 엔드포인트를 구현해야 합니다.
      // (다음 목차에서 설명합니다)
      const notified = await fetch(`${SERVER_BASE_URL}/payment/complete`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        // imp_uid와 merchant_uid, 주문 정보를 서버에 전달합니다
        body: JSON.stringify({
          imp_uid: response.imp_uid,
          merchant_uid: response.merchant_uid,
          // 주문 정보...
        }),
      });
    },
  );
  ```

  결제가 완료되면 반환되는 응답 객체([response](/opi/ko/integration/sdk/javascript-sdk-old/readme))의
  에러 여부에 따라 처리 로직을 콜백 함수에 작성합니다.
  요청이 성공했을 경우에 결제번호(`imp_uid`)와 주문번호(`merchant_uid`)를
  서버에 전달하는 로직을 위와 같이 작성합니다.

  <Hint style="danger">
    최종 결제 결과 처리는 반드시 [웹훅](/opi/ko/integration/webhook/readme-v1)을 이용하여
    안정적으로 처리해 주셔야 합니다.

    웹훅 연동을 생략하시는 경우 결제 결과를 정상적으로 수신받지 못하는 상황이 발생합니다.
  </Hint>
</VersionGate>

<VersionGate v="v2">
  `PortOne.requestPayment()` 함수의 반환값을 통해 결제 요청의 결과를 확인할 수 있습니다.

  `code != null`이면 결제 과정에서 오류가 발생한 것이므로 적절히 처리하여야 합니다.

  결제가 성공한 경우 `paymentId`를 서버에 전달하여 서버 측에서 결제 완료 처리를 진행하도록 합니다.
  (가상 계좌 결제의 경우 결제가 아직 완료되지 않은 상태일 수 있습니다)

  ```ts
  async function requestPayment() {
    const response = await PortOne.requestPayment({
      /* 파라미터 생략 */
    });

    if (response.code != null) {
      // 오류 발생
      return alert(response.message);
    }

    // 고객사 서버에서 /payment/complete 엔드포인트를 구현해야 합니다.
    // (다음 목차에서 설명합니다)
    const notified = await fetch(`${SERVER_BASE_URL}/payment/complete`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      // paymentId와 주문 정보를 서버에 전달합니다
      body: JSON.stringify({
        paymentId: paymentId,
        // 주문 정보...
      }),
    });
  }
  ```

  결과값에 들어 있는 필드는 다음과 같습니다.

  |필드명     |설명      |비고        |
  |-----------|----------|------------|
  |`paymentId`|결제 건 ID|공통        |
  |`code`     |오류 코드 |실패 시 포함|
  |`message`  |오류 문구 |실패 시 포함|
</VersionGate>

#### URL 쿼리 문자열로 처리하기 <span id="handle-redirect" />

모바일 환경에서의 결제는 대부분 리다이렉트 방식으로 이루어집니다.
리다이렉트 방식에서는 브라우저가 결제창으로 리다이렉트되었다가,
결제창에서의 작업이 끝나면 지정한
<VersionGate v="v1">`m_redirect_url`</VersionGate><VersionGate v="v2">`redirectUrl`</VersionGate>로
다시 리다이렉트됩니다.
이 경우에는 함수 호출 결과를 이용할 수 없고,
결제 성공 여부 등은 [쿼리 문자열](http://en.wikipedia.org/wiki/Query_string)로 전달받게 됩니다.

<VersionGate v="v1">
  ```ts
  IMP.request_pay({
    /* 기타 파라미터 생략 */
    m_redirect_url: `${BASE_URL}/payment-redirect`,
  }); // 리다이렉트 방식의 경우 콜백은 실행되지 않습니다.
  ```
</VersionGate>

<VersionGate v="v2">
  ```ts
  PortOne.requestPayment({
    /* 기타 파라미터 생략 */
    redirectUrl: `${BASE_URL}/payment-redirect`,
  });
  ```
</VersionGate>

쿼리 문자열로 전달되는 내용은 다음과 같습니다.

<VersionGate v="v1">
  |키            |설명                 |비고        |
  |--------------|---------------------|------------|
  |`imp_uid`     |포트원 결제 ID       |공통        |
  |`merchant_uid`|고객사 주문 고유 번호|공통        |
  |`error_code`  |오류 코드            |실패 시 포함|
  |`error_msg`   |오류 문구            |실패 시 포함|

  예를 들어 `merchant_uid`가 `payment-39ecfa97`, `m_redirect_url`이 `https://example.com/payment-redirect`인 경우,
  결제 성공 시에 `https://example.com/payment-redirect?merchant_uid=payment-39ecfa97`로 리다이렉트됩니다.
</VersionGate>

<VersionGate v="v2">
  |키          |설명      |비고        |
  |------------|----------|------------|
  |`payment_id`|결제 건 ID|공통        |
  |`code`      |오류 코드 |실패 시 포함|
  |`message`   |오류 문구 |실패 시 포함|

  예를 들어 `paymentId`가 `payment-39ecfa97`, `redirectUrl`이 `https://example.com/payment-redirect`인 경우,
  결제 성공 시에 `https://example.com/payment-redirect?payment_id=payment-39ecfa97`로 리다이렉트됩니다.
</VersionGate>

### 4. 결제 완료 처리하기 <span id="complete" />

<VersionGate v="v1">
  `imp_uid`와 `merchant_uid`를 서버에 전달하면, 서버는 포트원의 [결제 조회 API](/api/rest-v1/payment#get%20%2Fpayments%2F%7Bimp_uid%7D)를
  호출하여 해당 결제 건의 상태를 확인하고 결제 완료 처리를 진행하여야 합니다.
</VersionGate>

<VersionGate v="v2">
  `paymentId`를 서버에 전달하면, 서버는 포트원의 [결제 조회 API](/api/rest-v2/payment#get%20%2Fpayments%2F%7BpaymentId%7D)를
  호출하여 해당 결제 건의 상태를 확인하고 결제 완료 처리를 진행하여야 합니다.
</VersionGate>

<Hint style="info">
  **결제 검증 필수**

  인증 결제의 흐름상 결제 금액 등 정보가 고객의 브라우저 측에서 처리되므로,
  의도한 결제 내용이 맞는지 서버 측에서 꼭 확인하여야 위변조를 막을 수 있습니다.
</Hint>

예시로, 위에서 사용했던 `/payment/complete` 엔드포인트를 다음과 같이 구현할 수 있습니다.

<VersionGate v="v1">
  ```ts title="Express"
  // JSON 요청을 처리하기 위해 body-parser 미들웨어 세팅
  app.use(bodyParser.json());

  // POST 요청을 받는 /payments/complete
  app.post("/payment/complete", async (req, res) => {
    try {
      // 요청의 body로 imp_uid와 merchant_uid가 전달되기를 기대합니다.
      const { imp_uid, merchant_uid } = req.body;

      // 1. 포트원 API 엑세스 토큰 발급
      const tokenResponse = await fetch("https://api.iamport.kr/users/getToken", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          imp_key: "imp_apikey", // REST API 키
          imp_secret: "ekKoeW8RyKuT0zgaZsUtXXTLQ4AhPFW", // REST API Secret
        }),
      });
      if (!tokenResponse.ok)
        throw new Error(`tokenResponse: ${await tokenResponse.json()}`);
      const { access_token } = await tokenResponse.json();

      // 2. 포트원 결제내역 단건조회 API 호출
      const paymentResponse = await fetch(
        `https://api.iamport.kr/payments/${imp_uid}`,
        { headers: { Authorization: access_token } },
      );
      if (!paymentResponse.ok)
        throw new Error(`paymentResponse: ${await paymentResponse.json()}`);
      const payment = await paymentResponse.json();

      // 3. 고객사 내부 주문 데이터의 가격과 실제 지불된 금액을 비교합니다.
      const order = await OrderService.findById(merchant_uid);
      if (order.amount === payment.amount) {
        switch (payment.status) {
          case "ready": {
            // 가상 계좌가 발급된 상태입니다.
            // 계좌 정보를 이용해 원하는 로직을 구성하세요.
            break;
          }
          case "paid": {
            // 모든 금액을 지불했습니다! 완료 시 원하는 로직을 구성하세요.
            break;
          }
        }
      } else {
        // 결제 금액이 불일치하여 위/변조 시도가 의심됩니다.
      }
    } catch (e) {
      // 결제 검증에 실패했습니다.
      res.status(400).send(e);
    }
  });
  ```
</VersionGate>

<VersionGate v="v2">
  [PORTONE\_API\_SECRET](/opi/ko/integration/ready/readme?v=v2#4-2-v2-api-secret-%EB%B0%9C%EA%B8%89%ED%95%98%EA%B8%B0)
  은 V2 전용 시크릿으로, 포트원 콘솔 내 결제연동 탭에서 발급받을 수 있습니다.

  ```ts title="Express"
  // JSON 요청을 처리하기 위해 body-parser 미들웨어 세팅
  app.use(bodyParser.json());

  // POST 요청을 받는 /payments/complete
  app.post("/payment/complete", async (req, res) => {
    try {
      // 요청의 body로 paymentId가 전달되기를 기대합니다.
      const { paymentId, orderId } = req.body;

      // 1. 포트원 결제내역 단건조회 API 호출
      const paymentResponse = await fetch(
        `https://api.portone.io/payments/${paymentId}`,
        { headers: { Authorization: `PortOne ${PORTONE_API_SECRET}` } },
      );
      if (!paymentResponse.ok)
        throw new Error(`paymentResponse: ${await paymentResponse.json()}`);
      const payment = await paymentResponse.json();

      // 2. 고객사 내부 주문 데이터의 가격과 실제 지불된 금액을 비교합니다.
      const order = await OrderService.findById(orderId);
      if (order.amount === payment.amount.total) {
        switch (payment.status) {
          case "VIRTUAL_ACCOUNT_ISSUED": {
            // 가상 계좌가 발급된 상태입니다.
            // 계좌 정보를 이용해 원하는 로직을 구성하세요.
            break;
          }
          case "PAID": {
            // 모든 금액을 지불했습니다! 완료 시 원하는 로직을 구성하세요.
            break;
          }
        }
      } else {
        // 결제 금액이 불일치하여 위/변조 시도가 의심됩니다.
      }
    } catch (e) {
      // 결제 검증에 실패했습니다.
      res.status(400).send(e);
    }
  });
  ```
</VersionGate>

## **비인증결제**

## 비인증 결제란?

카드 번호, 유효기간, 카드 소유주 생년월일, 비밀번호 2자리 등 카드 정보를 직접 입력하여 일회성 결제(키인(수기)결제)
방식과 카드 정보를 이용하여 빌링키를 발급하고 판매자가 원하는 시점에 고객의 별도 인증 없이 결제를 요청하는 방식을 통칭합니다.

<Hint style="info">
  구매자의 인증 없이도 결제를 진행할 수 있어 간편하다는 장점이 있지만 구매자 인증 과정이 생략되는만큼
  서비스 운영 중 보안상의 이슈가 발생할 확률이 높아 **결제대행사 가입 시 입점심사가 까다롭게 진행**된다는 점 참고해주세요.
</Hint>

## 키인결제

구매자 인증 없이 카드정보만으로 결제되는 방식(일회성 결제)입니다.
키인(수기) 결제는 카드 정보를 입력하는 것만으로 별도 인증절차 없이 결제가 이루어지며,
결제는 일회성으로 진행되고 카드정보를 저장하지 않기 때문에 결제 요청 시 매번 카드정보를 입력해야 합니다.

<Hint style="info">
  주로 ARS를 통해 고객분께 카드 정보를 획득하여 결제를 요청하는 콜센타 또는
  인증결제의 번거로움을 회피하기 위해 일부 고객사에서 사용하는 방식입니다.
  최근에는 인증결제가 간편결제방식으로 전환되면서
  매번 카드정보를 기입해야 하는 번거로움 때문에 많이 사용되지 않은 방식입니다.
</Hint>

카드 정보를 바탕으로 [비 인증 결제(일회성) API](http://developers.portone.io/api/rest-v1/nonAuthPayment#post%20%2Fsubscribe%2Fpayments%2Fonetime)
를 이용하여 결제를 진행하는 방식입니다.

- 지원 결제대행사
- 이니시스
- NHN KCP
- 나이스페이먼츠 (구모듈, 신모듈)
- 토스페이먼츠 (신모듈)
- 키움페이
- KSNET
- 웰컴페이먼츠
- 헥토파이낸셜

```ts title="server-side"
// card_number, expiry, birth, pwd_2digit 등 정보를 전달받습니다.
// 포트원 비인증 결제(일회성) API 호출
const onetimeResponse = await fetch(
  "https://api.iamport.kr/subscribe/payments/onetime",
  {
    method: "POST",
    headers: {
      Authorization: `Bearer ${ACCESS_TOKEN}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      pg: `${pg_provider}.${pg_mid}`,
      card_number: "YYYY-YYYY-YYYY-YYYY", // 카드 번호 16자리
      expiry: "YYYY-MM", // 카드 유효기간
      birth: "YYMMDD", // 생년 월일. 무기명 법인카드의 경우 사업자 번호 10자리 입력
      pwd_2digit: "NN", //카드 비밀번호 앞 2자리
      // 중략...
    }),
  },
);
```

## 빌링키 결제

카드 정보를 바탕으로 빌링키를 발급한 후 해당 빌링키를 이용하여 결제되는 방식입니다.
빌링키를 이용하여 즉시 결제 또는 결제를 예약하여 정기결제 형식으로 이용할 수 있습니다.

<Hint style="info">
  **빌링키란?**

  구독형 정기결제, 종량제 과금결제 등 구현 시 원하는 시점에 재 결제를 진행할 수 있는 결제용 암호화 키 입니다.
  고객사가 고객의 카드 정보를 소유할 수 없기 때문에 카드사로부터 해당 카드에 대응하는 빌링키를
  발급받아 저장하고, 이후 원하는 시점에 해당 빌링키로 결제를 청구하기 위해 사용합니다.
</Hint>

### 빌링키 발급하기

빌링키는 결제대행사에 따라 다음 두 가지 방식을 이용하여 발급받을 수 있습니다.

#### REST API 방식

고객 결제 정보를 이용하여 [빌링키 발급 API](http://developers.portone.io/api/rest-v1/billingkey#post%20%2Fsubscribe%2Fcustomers%2F%7Bcustomer_uid%7D)를
호출하면 포트원 서버가 결제대행사를 통해 빌링키를 발급받습니다.

이 과정에서 고객의 카드 정보는 포트원 서버에 기록되지 않습니다.

브라우저로부터 결제 정보를 전달 받은 뒤, 서버에서 포트원 API를 호출하세요.

- **장점**
  - 고객사가 원하는 형태의 화면으로 **카드정보 입력란을 커스터마이징**할 수 있습니다.
  - 고객사 UI/UX 친화적인 결제 환경을 계획하고 계시다면 API 연동 개발을 선택하시길 권장드립니다.

- **단점**
  - **개인정보 이용약관**을 명시해야 하며 PG사 및 카드사 심사가 까다롭고 개인정보 유출에 유의해야 합니다.
  - **지원 결제대행사**

- 이니시스

- NHN KCP

- 나이스페이먼츠 (구모듈, 신모듈)

- 토스페이먼츠 (신모듈)

- 키움페이

- KSNET

- 웰컴페이먼츠

- 헥토파이낸셜

```ts title="server-side"
// customer_uid, card_number, expiry, birth, pwd_2digit 등 정보를 전달받습니다.
// 포트원 빌링키 발급 API 호출
const issueResponse = await fetch(
  `https://api.iamport.kr/subscribe/customers/${customer_uid}`,
  {
    method: "POST",
    headers: {
      Authorization: `Bearer ${ACCESS_TOKEN}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      pg: `${pg_provider}.${pg_mid}`,
      customer_id: customer_id, //고객 식별 정보로 고객사에서 기입
      card_number: "YYYY-YYYY-YYYY-YYYY", // 카드 번호 16자리
      expiry: "YYYY-MM", // 카드 유효기간
      birth: "YYMMDD", // 생년 월일. 무기명 법인카드의 경우 사업자 번호 10자리 입력
      pwd_2digit: "NN", //카드 비밀번호 앞 2자리
      // 중략...
    }),
  },
);
if (!issueResponse.ok)
  throw new Error(`issueResponse: ${await issueResponse.json()}`);
const {
  billingKeyInfo: { customer_uid },
} = await issueResponse.json();
// 빌링키가 발급되었습니다! 빌링키를 저장하거나 결제하는 로직을 구성하세요.
```

#### 결제창(SDK) 방식

결제창을 이용해 빌링키를 발급할 때는 포트원 SDK를 이용합니다.

포트원 SDK를 설치하는 방법은
[포트원 SDK 설치하기](http://developers.portone.io/docs/ko/authpay/guide?v=v1#1-포트원-sdk-설치하기) 문서를 참고하세요.

`IMP.request_pay()` 함수를 호출 시 `customer_uid` 파라미터를 포함하는 경우 빌링키를 발급하기 위한
결제창을 열 수 있습니다.

브라우저에서 포트원 SDK를 호출하여 빌링키를 발급하고, 서버로 빌링키를 전달합니다.

- **장점**
  - 결제 수단 정보가 고객사나 포트원의 서버를 거치지 않고 직접 PG사로 전달되기 때문에 보안 문제가 일어날 가능성이 적습니다.

- **단점**
  - PG사의 일반결제창을 통해 카드정보를 입력받기 때문에 웹브라우저를 통해서만 빌링키 발급이 이루어지며,
    **카드정보 입력란을 커스터마이징 할 수 없습니다.**

- **지원 결제대행사**
  - 이니시스
  - NHN KCP
  - 토스페이먼츠 (신모듈)
  - 다날
  - 이지페이(KICC)
  - 모빌리언스 (휴대폰 소액결제 한정)
  - 웰컴페이먼츠
  - 스마트로 (신모듈)
  - 헥토파이낸셜 (내통장 결제 한정)
  - 카카오페이
  - 네이버페이 (결제형 한정)
  - 페이코
  - 스마일페이
  - 토스페이 (신모듈)
  - 페이먼트월
  - 페이팔 (RT)

```ts
IMP.request_pay(
  {
    customer_uid: "gildong_0001_1234", // 카드(빌링키)와 1:1로 대응하는 값
    /* ...생략... */
  },
  function (rsp) {
    // callback
    if (rsp.success) {
      // 빌링키 발급 성공
    } else {
      // 빌링키 발급 실패
    }
  },
);
```

#### 유의사항

<Hint style="info">
  **`customer_uid` 란?**

  PG사가 발급한 빌링키와 1:1로 맵핑되는, 고객사가 지정한 고유한 값입니다.
  `customer_uid`는 카드 번호 단위로 구분하여 저장되어야 합니다.

  예) **홍길동** 고객이 **A 카드** 빌링키를 요청하는 경우
  `customer_uid`는 **회원별 카드 번호 단위**로 고유하게 발급되어야 합니다.
</Hint>

<Hint style="danger">
  이전 빌링키 발급에 사용된 `customer_uid`를 재사용하는 경우 가장 마지막 빌링키 발급에 사용된
  카드번호의 빌링키로 대체됩니다. (**기존에 발급된 빌링키는 자동으로 해지되지 않습니다.**)
</Hint>

### 빌링키 결제 요청하기

발급 받은 포트원 빌링키를 이용하여 [비 인증 결제(빌링키) API](http://developers.portone.io/api/rest-v1/nonAuthPayment#post%20%2Fsubscribe%2Fpayments%2Fagain)
또는 [결제 예약 API](http://developers.portone.io/api/rest-v1/nonAuthPayment.subscribe#post%20%2Fsubscribe%2Fpayments%2Fschedule)
를 호출하여 즉시 결제 및 결제 예약을 진행합니다.

#### 즉시 결제

<Hint style="info">
  **빌링키 발급과 결제 요청을 한번에 하기**

  [결제 예약 API](http://developers.portone.io/api/rest-v1/nonAuthPayment.subscribe#post%20%2Fsubscribe%2Fpayments%2Fschedule)를
  사용하면 등록된 customer\_uid가 없는 경우 빌링키 신규 발급을 먼저 진행한 후 schedule정보를 예약합니다.(카드정보 필수사항)
</Hint>

[비 인증 결제(빌링키) API](http://developers.portone.io/api/rest-v1/nonAuthPayment#post%20%2Fsubscribe%2Fpayments%2Fagain)
를 참고하여 파라미터를 입력한 후 결제 요청해야 합니다.

```ts title="server-side"
// 포트원 빌링키 결제 API 호출
const paymentResponse = await fetch(
  "https://api.iamport.kr/subscribe/payments/again",
  {
    method: "POST",
    headers: {
      Authorization: `Bearer ${ACCESS_TOKEN}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      customer_uid,
      merchant_uid,
      name: "월간 이용권 정기결제",
      // 빌링키 결제 API를 참고해 고객 정보를 채워주세요.
      amount: {
        total: 8900,
      },
      currency: "KRW",
    }),
  },
);
if (!paymentResponse.ok)
  throw new Error(`paymentResponse: ${await paymentResponse.json()}`);
```

#### 예약/반복결제

**1. 결제 예약하기**

미래 특정 시점에 결제가 진행되도록 결제를 예약할 수 있습니다.
포트원 [결제 예약 API](http://developers.portone.io/api/rest-v1/nonAuthPayment.subscribe#post%20%2Fsubscribe%2Fpayments%2Fschedule)
를 이용하여 원하시는 시점에 결제 예약을 손쉽게 등록할 수 있습니다.

```ts title="server-side"
// 결제 예약
axios({
  url: `https://api.iamport.kr/subscribe/payments/schedule`,
  method: "post",
  headers: { Authorization: access_token },
  data: {
    customer_uid: "gildong_0001_1234", // 카드(빌링키)와 1:1로 대응하는 값
    schedules: [
      {
        merchant_uid: "order_monthly_0001", // 주문 번호
        schedule_at: 1519862400, // 결제 시도 시각 in Unix Time Stamp. 예: 다음 달 1일
        amount: 8900,
        name: "월간 이용권 정기결제",
        buyer_name: "홍길동",
        buyer_tel: "01012345678",
        buyer_email: "gildong@gmail.com",
      },
    ],
  },
});
```

**2. 결제 결과 수신하기**

예약한 시간에 결제가 시도되면 Webhook 이벤트가 발생하여 지정한 서버의 callback URL로 결제
번호(`imp_uid`)와 주문 번호(`merchant_uid`)가 전달됩니다. 웹훅으로 예약결제에 대한 결과를 수신하면
결제결과 완료 로직 처리를 진행합니다.

<Hint style="info">
  **포트원 Webhook**

  포트원 Webhook의 개념과 URL 설정 방법은 [**포트원 Webhook**](/opi/ko/integration/webhook/readme-v1) 문서를 참고하세요.
</Hint>

```ts title="server-side"
// "/iamport-callback/schedule"에 대한 POST 요청을 처리
app.post("/iamport-callback/schedule", async (req, res) => {
  try {
    const { imp_uid, merchant_uid } = req.body;
    // 액세스 토큰(access token) 발급 받기
    const getToken = await axios({
      url: "https://api.iamport.kr/users/getToken",
      method: "post", // POST method
      headers: { "Content-Type": "application/json" },
      data: {
        imp_key: "imp_apikey", // REST API 키
        imp_secret:
          "ekKoeW8RyKuT0zgaZsUtXXTLQ4AhPFW3ZGseDA6bkA5lamv9OqDMnxyeB9wqOsuO9W3Mx9YSJ4dTqJ3f",
      },
    });
    const { access_token } = getToken.data; // 인증 토큰
    // imp_uid로 포트원 서버에서 결제 정보 조회
    const getPaymentData = await axios({
      url: `https://api.iamport.kr/payments/${imp_uid}`, // imp_uid 전달
      method: "get", // GET method
      headers: { Authorization: access_token },
    });
    const paymentData = getPaymentData.data; // 조회한 결제 정보
    const { status } = paymentData;
    if (status === "paid") {
      // 결제 성공적으로 완료
      // DB에 결제 정보 저장
      await Orders.findByIdAndUpdate(merchant_uid, { $set: paymentData }); // Mongoose
      // ...
    } else {
      // 재결제 시도
    }
  } catch (e) {
    res.status(400).send(e);
  }
});
```

**3. 반복결제 구현하기**

포트원 서버에 결제 예약 요청을 하고 예약한 시간에 결제가 시도되면 지정된 웹훅 URL을 통해서
서버에 알리는 과정을 반복적으로 수행하여 반복 결제를 구현할 수 있습니다.

<Figure src={Image1} />

예약된 결제가 시도되었을 때 발생하는 webhook 이벤트를 처리하는 로직에서 예약된 결제가 정상적으로 완료되고 결제 내역이 저장되면 다음 결제를 예약하는 예제입니다.

```ts title="server-side"
// "/iamport-callback/schedule"에 대한 POST 요청을 처리
app.post("/iamport-callback/schedule", async (req, res) => {
  try {
    const { imp_uid, merchant_uid } = req.body;
    // 액세스 토큰(access token) 발급 받기
    /* ...중략 ... */
    // imp_uid로 포트원 서버에서 결제 정보 조회
    /* ...중략 ... */
    const paymentData = getPaymentData.data; // 조회한 결제 정보
    const { status } = paymentData;
    if (status === "paid") {
      // 결제 성공적으로 완료
      // DB에 결제 정보 저장
      await Orders.findByIdAndUpdate(merchant_uid, { $set: paymentData });
      // ...
      // 새로운 결제 예약
      axios({
        url: "{결제예약을 받을 서비스 URL}",
        method: "post",
        // 인증 토큰 Authorization header에 추가
        headers: { Authorization: access_token },
        data: {
          customer_uid: "gildong_0001_1234", // 카드(빌링키)와 1:1로 대응하는 값
          schedules: [
            {
              // 주문 번호
              merchant_uid: "order_monthly_0001",
              // 결제 시도 시각 in Unix Time Stamp. 예: 다음 달 1일
              schedule_at: 1519516800,
              amount: 8900,
              name: "월간 이용권 정기결제",
              // ...
            },
          ],
        },
      });
    } else {
      // 재결제 시도
    }
  } catch (e) {
    res.status(400).send(e);
  }
});
```
